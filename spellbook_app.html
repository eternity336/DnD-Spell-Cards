<!DOCTYPE html>
<html lang="en" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spellbook</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script>
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
          document.documentElement.classList.add('dark')
        } else {
          document.documentElement.classList.remove('dark')
        }
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        .dark .custom-scrollbar::-webkit-scrollbar-track { background: #2d3748; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        .dark .custom-scrollbar::-webkit-scrollbar-thumb { background: #555; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #555; }
        .dark .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #444; }
        .modal-overlay { transition: opacity 0.3s ease; }
        .mode-button[data-active="true"] { background-color: #4f46e5; color: white; }
        .mode-button[data-active="false"] { background-color: #e5e7eb; color: #374151; }
        .dark .mode-button[data-active="false"] { background-color: #374151; color: #d1d5db; }
        .pin-input { width: 3rem; height: 3rem; text-align: center; font-size: 1.5rem; }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 h-screen flex flex-col p-4 transition-colors duration-300">

    <div id="app-container" class="w-full max-w-6xl mx-auto flex flex-col flex-grow">
        <!-- HEADER -->
        <header class="mb-6">
            <div class="flex justify-between items-center mb-4">
                <h1 class="text-3xl font-bold text-gray-900 dark:text-white">Spellbook</h1>
                <div class="flex items-center gap-2 flex-wrap justify-end">
                    <input type="file" id="csv-import-input" class="hidden" accept=".csv" onchange="handleCsvFileSelect(event)">
                    <button onclick="openGoogleSheetImportModal()" class="px-4 py-2 bg-teal-600 text-white font-semibold rounded-md hover:bg-teal-700">Import from Google Sheet</button>
                    <button onclick="document.getElementById('csv-import-input').click()" class="px-4 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700">Import CSV File</button>
                    <button onclick="openAddSpellModal()" class="px-4 py-2 bg-green-600 text-white font-semibold rounded-md hover:bg-green-700">+ Add New Spell</button>
                    <button id="theme-toggle" class="p-2 rounded-full text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700">
                        <svg id="theme-icon-light" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                        <svg id="theme-icon-dark" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
                    </button>
                </div>
            </div>
            <div class="p-4 bg-white dark:bg-gray-800 rounded-lg shadow-md flex flex-col sm:flex-row gap-4 items-center justify-between">
                <div class="flex-grow w-full sm:w-auto">
                    <label for="persona-select" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Current Player</label>
                    <select id="persona-select" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-indigo-500 focus:border-indigo-500"></select>
                </div>
                <div class="w-full sm:w-auto flex items-end gap-2">
                    <button onclick="openAddPersonaModal()" class="px-4 py-2 bg-green-600 text-white font-semibold rounded-md hover:bg-green-700 whitespace-nowrap">New Player</button>
                    <button id="delete-persona-btn" onclick="requestDeletePersona()" class="px-4 py-2 bg-red-600 text-white font-semibold rounded-md hover:bg-red-700 whitespace-nowrap hidden">Delete Player</button>
                </div>
            </div>
        </header>
        
        <!-- MODE SELECTOR -->
        <div id="mode-selector" class="mb-4 hidden">
            <div class="bg-gray-200 dark:bg-gray-700 rounded-lg p-1 flex w-full sm:w-1/3">
                <button id="view-mode-btn" onclick="switchToViewMode()" class="mode-button flex-1 p-2 rounded-md font-semibold transition-colors" data-active="true">View</button>
                <button id="edit-mode-btn" onclick="requestEditMode()" class="mode-button flex-1 p-2 rounded-md font-semibold transition-colors" data-active="false">Edit</button>
            </div>
        </div>

        <!-- MAIN CONTENT -->
        <main id="main-content" class="mt-6 flex-grow">
            <!-- VIEW MODE -->
            <div id="view-mode-container" class="grid grid-cols-1 md:grid-cols-2 gap-6 h-full">
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md flex flex-col">
                    <div class="p-4 border-b dark:border-gray-700">
                        <h2 id="spell-list-title" class="text-xl font-bold mb-2">All Spells</h2>
                        <input type="text" id="search-input-view" onkeyup="handleSearch()" class="w-full p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600" placeholder="Search spells...">
                    </div>
                    <div id="spell-list" class="overflow-y-auto custom-scrollbar p-2 flex-grow"></div>
                </div>
                <div id="spell-card-view" class="bg-white dark:bg-gray-800 rounded-lg shadow-md flex flex-col">
                    <div id="spell-card-content" class="p-6 overflow-y-auto custom-scrollbar flex-grow">
                        <h2 id="spell-name-display" class="text-3xl font-bold mb-2 text-indigo-600 dark:text-indigo-400">Select a Spell</h2>
                        <p id="spell-level-school-display" class="text-lg text-gray-500 dark:text-gray-400 mb-4"></p>
                        <div id="spell-details-display" class="space-y-3 text-left"></div>
                    </div>
                </div>
            </div>
            
            <!-- EDIT MODE -->
            <div id="edit-mode-container" class="grid grid-cols-1 md:grid-cols-2 gap-6 h-full hidden">
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md flex flex-col">
                     <div class="p-4 border-b dark:border-gray-700">
                        <h2 class="text-xl font-bold mb-2">Global Spell List</h2>
                        <input type="text" id="search-input-edit-global" onkeyup="handleSearch()" class="w-full p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600" placeholder="Search spells...">
                    </div>
                    <div id="edit-global-list" class="overflow-y-auto custom-scrollbar p-2 flex-grow"></div>
                </div>
                 <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md flex flex-col">
                    <div class="p-4 border-b dark:border-gray-700"><h2 id="edit-persona-list-title" class="text-xl font-bold">Player's Spells</h2></div>
                    <div id="edit-persona-list" class="overflow-y-auto custom-scrollbar p-2 flex-grow"></div>
                </div>
            </div>
        </main>
    </div>

    <!-- MODALS CONTAINER -->
    <div id="modal-container"></div>

    <!-- FIREBASE AND APP SCRIPT -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.1/firebase-app.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, collection, writeBatch, deleteDoc } from "https://www.gstatic.com/firebasejs/9.17.1/firebase-firestore.js";

        // --- PASTE YOUR FIREBASE CONFIGURATION HERE ---
        const firebaseConfig = {
            apiKey: "AIzaSyBbFkH2eqqdAyXe51BFXhHwn9Ppt_PiJXI",
            authDomain: "dnd-spellbook-c5d20.firebaseapp.com",
            projectId: "dnd-spellbook-c5d20",
            storageBucket: "dnd-spellbook-c5d20.appspot.com",
            messagingSenderId: "544494656753",
            appId: "1:544494656753:web:bd2be959508ba757369d50",
            measurementId: "G-RY3HJB9B7J"
        };
        // ---------------------------------------------

        // --- GLOBAL VARIABLES ---
        let db;
        let allSpells = [];
        let personas = {};
        let currentPersona = null;
        let currentUserAccess = null;
        let activeSpell = null;
        let currentMode = 'view';
        let spellsUnsubscribe = null;
        let personasUnsubscribe = null;

        // --- INITIALIZATION ---
        function initializeFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                setupListeners();
            } catch (e) {
                console.error("Firebase initialization failed:", e);
                alert("Firebase is not configured. Please follow the setup guide and paste your firebaseConfig object into the HTML file.");
            }
        }
        
        function setupListeners() {
            const spellsRef = collection(db, "spells");
            spellsUnsubscribe = onSnapshot(spellsRef, (snapshot) => {
                allSpells = snapshot.docs.map(doc => doc.data());
                allSpells.sort((a, b) => (a['Spell Name'] || '').localeCompare(b['Spell Name'] || ''));
                renderAppLayout();
            }, (error) => {
                console.error("Error fetching spells:", error);
                alert("Could not connect to the spells database. Please check your Firestore security rules and ensure the 'spells' collection exists.");
            });

            const personasRef = doc(db, "appData", "personas");
            personasUnsubscribe = onSnapshot(personasRef, (doc) => {
                personas = doc.exists() ? doc.data() : {};
                updatePersonaDropdown();
                 if (currentPersona && !personas[currentPersona]) {
                    currentPersona = null;
                    currentUserAccess = null;
                }
                renderAppLayout();
            }, (error) => {
                console.error("Error fetching personas:", error);
                 alert("Could not connect to the player database. Please check your Firestore security rules.");
            });
        }

        // --- THEME ---
        function initTheme() {
            const themeToggle = document.getElementById('theme-toggle');
            const lightIcon = document.getElementById('theme-icon-light');
            const darkIcon = document.getElementById('theme-icon-dark');
            if (document.documentElement.classList.contains('dark')) {
                darkIcon.classList.remove('hidden');
            } else {
                lightIcon.classList.remove('hidden');
            }
            themeToggle.addEventListener('click', () => {
                document.documentElement.classList.toggle('dark');
                lightIcon.classList.toggle('hidden');
                darkIcon.classList.toggle('hidden');
                localStorage.theme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
            });
        }
        
        // --- HASHING ---
        async function hashPin(pin) {
            if (!pin) return null;
            const encoder = new TextEncoder();
            const data = encoder.encode(pin);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // --- LAYOUT & UI ---
        function renderAppLayout() {
            const modeSelector = document.getElementById('mode-selector');
            const viewContainer = document.getElementById('view-mode-container');
            const editContainer = document.getElementById('edit-mode-container');
            const deleteBtn = document.getElementById('delete-persona-btn');

            if (currentPersona) {
                modeSelector.classList.remove('hidden');
                deleteBtn.classList.remove('hidden');
                document.getElementById('edit-mode-btn').disabled = currentUserAccess !== 'owner';

                if (currentMode === 'view') {
                    viewContainer.classList.remove('hidden');
                    editContainer.classList.add('hidden');
                    renderSpellList();
                } else { 
                    if (currentUserAccess === 'owner') {
                        viewContainer.classList.add('hidden');
                        editContainer.classList.remove('hidden');
                        renderEditView();
                    } else {
                        switchToViewMode();
                    }
                }
            } else {
                modeSelector.classList.add('hidden');
                deleteBtn.classList.add('hidden');
                viewContainer.classList.remove('hidden');
                editContainer.classList.add('hidden');
                renderSpellList();
            }
             handleSearch();
        }
        
        function switchToViewMode() {
            currentMode = 'view';
            document.getElementById('view-mode-btn').dataset.active = 'true';
            document.getElementById('edit-mode-btn').dataset.active = 'false';
            renderAppLayout();
        }

        async function requestEditMode() {
            const persona = personas[currentPersona];
            if (!persona) return;
            if (persona.ownerPinHash) {
                openPinModal('Owner Access Required', `Enter the Owner PIN for ${currentPersona} to edit spells.`, async (pin) => {
                    const hashedPin = await hashPin(pin);
                    if (hashedPin === persona.ownerPinHash) {
                        currentUserAccess = 'owner';
                        switchToEditModeActual();
                    } else {
                        alert('Incorrect PIN.');
                    }
                });
            } else {
                currentUserAccess = 'owner';
                switchToEditModeActual();
            }
        }

        function switchToEditModeActual() {
             currentMode = 'edit';
             document.getElementById('view-mode-btn').dataset.active = 'false';
             document.getElementById('edit-mode-btn').dataset.active = 'true';
             renderAppLayout();
        }

        function handleSearch() {
            let searchTerm = '';
            if (currentPersona && currentMode === 'edit') {
                 searchTerm = document.getElementById('search-input-edit-global').value.toLowerCase();
                 renderEditView();
            } else {
                 searchTerm = document.getElementById('search-input-view').value.toLowerCase();
                 renderSpellList(searchTerm);
            }
        }
        
        function renderSpellList(searchTerm = '') {
            const listEl = document.getElementById('spell-list');
            const titleEl = document.getElementById('spell-list-title');
            listEl.innerHTML = '';
            
            let sourceList;
            if (currentPersona) {
                titleEl.textContent = `${currentPersona}'s Spells`;
                const personaSpells = personas[currentPersona].spells || [];
                sourceList = allSpells.filter(s => personaSpells.includes(s['Spell Name']));
            } else {
                titleEl.textContent = 'Global Spell List';
                sourceList = allSpells;
            }

            const spellsToDisplay = sourceList.filter(spell => {
                if (!searchTerm) return true;
                return (spell['Spell Name'] && spell['Spell Name'].toLowerCase().includes(searchTerm)) ||
                       (spell['School'] && spell['School'].toLowerCase().includes(searchTerm)) ||
                       (spell['Level'] && spell['Level'].toLowerCase().includes(searchTerm)) ||
                       (spell['Description'] && spell['Description'].toLowerCase().includes(searchTerm));
            });

            if (spellsToDisplay.length === 0) {
                listEl.innerHTML = `<p class="p-4 text-gray-500 dark:text-gray-400">No spells found.</p>`;
                if (!activeSpell || !spellsToDisplay.map(s => s['Spell Name']).includes(activeSpell['Spell Name'])) {
                     displayEmptyCard(currentPersona ? "This player knows no spells." : "No spells in the database.");
                }
                return;
            }

            spellsToDisplay.forEach(spell => {
                const spellItem = document.createElement('div');
                spellItem.className = 'flex justify-between items-center p-3 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md cursor-pointer';
                spellItem.onclick = () => displaySpellCard(spell);
                spellItem.innerHTML = `<div><p class="font-semibold">${spell['Spell Name']}</p><p class="text-sm text-gray-500 dark:text-gray-400">${spell.Level} - ${spell.School}</p></div>`;
                listEl.appendChild(spellItem);
            });
            if (!activeSpell || !spellsToDisplay.map(s => s['Spell Name']).includes(activeSpell['Spell Name'])) {
                displaySpellCard(spellsToDisplay[0]);
            }
        }

        function renderEditView() {
            const globalListEl = document.getElementById('edit-global-list');
            const personaListEl = document.getElementById('edit-persona-list');
            const globalSearchTerm = document.getElementById('search-input-edit-global').value.toLowerCase();
            document.getElementById('edit-persona-list-title').textContent = `${currentPersona}'s Spells`;
            globalListEl.innerHTML = '';
            personaListEl.innerHTML = '';

            const personaSpells = personas[currentPersona].spells || [];

            const globalSpellsToDisplay = allSpells.filter(spell => {
                 if (!globalSearchTerm) return true;
                return (spell['Spell Name'] && spell['Spell Name'].toLowerCase().includes(globalSearchTerm)) ||
                       (spell['School'] && spell['School'].toLowerCase().includes(globalSearchTerm));
            });
            
            globalSpellsToDisplay.forEach(spell => {
                const spellItem = document.createElement('div');
                spellItem.className = 'flex justify-between items-center p-3 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md';
                spellItem.innerHTML = `<div><p class="font-semibold">${spell['Spell Name']}</p><p class="text-sm text-gray-500 dark:text-gray-400">${spell.Level} - ${spell.School}</p></div>`;
                
                const isAdded = personaSpells.includes(spell['Spell Name']);
                const addBtn = document.createElement('button');
                addBtn.innerText = isAdded ? 'âœ“ Added' : 'Add';
                addBtn.className = `px-3 py-1 text-sm rounded ${isAdded ? 'bg-gray-400 dark:bg-gray-600 cursor-default' : 'bg-indigo-600 text-white hover:bg-indigo-700'}`;
                if (!isAdded) {
                    addBtn.onclick = () => addSpellToPersona(spell['Spell Name']);
                }
                spellItem.appendChild(addBtn);
                globalListEl.appendChild(spellItem);
            });

            const spellsForPersona = allSpells.filter(s => personaSpells.includes(s['Spell Name']));
             if (spellsForPersona.length === 0) {
                personaListEl.innerHTML = `<p class="p-4 text-gray-500 dark:text-gray-400">No spells added yet.</p>`;
            } else {
                spellsForPersona.forEach(spell => {
                    const spellItem = document.createElement('div');
                    spellItem.className = 'flex justify-between items-center p-3 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md';
                    spellItem.innerHTML = `<div><p class="font-semibold">${spell['Spell Name']}</p><p class="text-sm text-gray-500 dark:text-gray-400">${spell.Level} - ${spell.School}</p></div>`;
                    
                    const removeBtn = document.createElement('button');
                    removeBtn.innerText = 'Remove';
                    removeBtn.className = 'px-3 py-1 text-sm bg-red-500 text-white rounded hover:bg-red-600';
                    removeBtn.onclick = () => removeSpellFromPersona(spell['Spell Name']);
                    spellItem.appendChild(removeBtn);
                    personaListEl.appendChild(spellItem);
                });
            }
        }

        function displaySpellCard(spell) {
            if (!spell) {
                displayEmptyCard("No spell selected.");
                return;
            }
            activeSpell = spell;
            document.getElementById('spell-name-display').textContent = spell['Spell Name'] || 'Unnamed Spell';
            document.getElementById('spell-level-school-display').textContent = `${spell['Level'] || 'N/A'} - ${spell['School'] || 'N/A'}`;
            const detailsContainer = document.getElementById('spell-details-display');
            detailsContainer.innerHTML = '';

            const detailsOrder = ['Level', 'School', 'Casting Time', 'Range', 'Components', 'Duration', 'Description', 'Higher Level'];
            detailsOrder.forEach(key => {
                 if (spell[key]) {
                    const detailEl = document.createElement('div');
                    detailEl.innerHTML = `<strong class="font-semibold text-gray-900 dark:text-gray-100">${key}:</strong> <span class="text-gray-700 dark:text-gray-300">${spell[key]}</span>`;
                    detailsContainer.appendChild(detailEl);
                }
            });
        }

        function displayEmptyCard(message) {
            activeSpell = null;
            document.getElementById('spell-name-display').textContent = message;
            document.getElementById('spell-level-school-display').textContent = '';
            document.getElementById('spell-details-display').innerHTML = '';
        }

        // --- DATA MODIFICATION ---
        async function savePersonas() {
            if (!db) return;
            try {
                await setDoc(doc(db, "appData", "personas"), personas);
            } catch (error) {
                console.error("Error saving personas:", error);
                alert("Could not save player data. Check your connection and Firestore security rules.");
            }
        }

        async function addSpellToPersona(spellName) {
            if (!currentPersona || !personas[currentPersona]) return;
            if (!personas[currentPersona].spells.includes(spellName)) {
                personas[currentPersona].spells.push(spellName);
                await savePersonas();
            }
        }
        
        async function removeSpellFromPersona(spellName) {
            if (!currentPersona || !personas[currentPersona]) return;
            const index = personas[currentPersona].spells.indexOf(spellName);
            if (index > -1) {
                personas[currentPersona].spells.splice(index, 1);
                await savePersonas();
            }
        }

        function updatePersonaDropdown() {
            const select = document.getElementById('persona-select');
            const selectedValue = select.value;
            select.innerHTML = '<option value="">-- Global Spell List --</option>';
            Object.keys(personas).sort().forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            });
            if (selectedValue && personas[selectedValue]) {
                select.value = selectedValue;
            } else {
                currentPersona = null;
                currentUserAccess = null;
            }
        }
        
        async function handlePersonaChange() {
            const selectedName = document.getElementById('persona-select').value;
            if (!selectedName) {
                currentPersona = null;
                currentUserAccess = null;
                switchToViewMode();
                renderAppLayout();
                return;
            }
            
            const persona = personas[selectedName];
            if (persona.ownerPinHash || persona.guestPinHash) {
                 openPinModal(`Login to ${selectedName}`, `Enter PIN to access this player.`, async (pin) => {
                    const hashedPin = await hashPin(pin);
                    if (persona.ownerPinHash && hashedPin === persona.ownerPinHash) {
                        currentUserAccess = 'owner';
                        currentPersona = selectedName;
                        switchToViewMode();
                    } else if (persona.guestPinHash && hashedPin === persona.guestPinHash) {
                        currentUserAccess = 'guest';
                        currentPersona = selectedName;
                        switchToViewMode();
                    } else {
                        alert('Incorrect PIN.');
                        document.getElementById('persona-select').value = ''; 
                    }
                }, true);
            } else {
                currentPersona = selectedName;
                currentUserAccess = 'owner'; 
                switchToViewMode();
            }
        }

        async function requestDeletePersona() {
            if (!currentPersona) return;
            if (confirm(`Are you sure you want to delete ${currentPersona}? This cannot be undone.`)) {
                const persona = personas[currentPersona];
                 if (persona.ownerPinHash) {
                    openPinModal('Confirm Deletion', `Enter the Owner PIN for ${currentPersona} to delete.`, async (pin) => {
                        const hashedPin = await hashPin(pin);
                        if (hashedPin === persona.ownerPinHash) {
                           delete personas[currentPersona];
                           await savePersonas();
                           document.getElementById('persona-select').value = '';
                           currentPersona = null;
                           currentUserAccess = null;
                        } else {
                            alert('Incorrect PIN. Deletion cancelled.');
                        }
                    });
                 } else {
                     delete personas[currentPersona];
                     await savePersonas();
                     document.getElementById('persona-select').value = '';
                     currentPersona = null;
                     currentUserAccess = null;
                 }
            }
        }
        
        // --- IMPORT LOGIC ---
        function handleCsvFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                 Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: async (results) => {
                        if (results.errors.length > 0) {
                            console.error("PapaParse Errors:", results.errors);
                            alert("There was an error parsing the CSV file. Please check the console for details.");
                        } else {
                            await processImportedSpells(results.data);
                        }
                    }
                });
            }
            event.target.value = ''; 
        }

        async function processImportedSpells(importedData) {
            const headerMapping = {
                'Name': 'Spell Name',
                'Details': 'Description',
                'Upcast': 'Higher Level'
            };

            const importedSpells = importedData.map(row => {
                 const spell = {};
                 for(const key in row) {
                     const appKey = headerMapping[key.trim()] || key.trim();
                     spell[appKey] = row[key];
                 }
                 return spell;
            }).filter(spell => spell['Spell Name'] && spell['Spell Name'].trim() !== '');
            
            let spellsToUpload = new Map();
            for (const newSpell of importedSpells) {
                const existingSpell = allSpells.find(s => s['Spell Name'].toLowerCase() === newSpell['Spell Name'].toLowerCase());
                if (existingSpell) {
                    const cleanExisting = JSON.stringify(Object.keys(existingSpell).sort().reduce((acc, key) => { if(existingSpell[key]) acc[key] = existingSpell[key]; return acc; }, {}));
                    const cleanNew = JSON.stringify(Object.keys(newSpell).sort().reduce((acc, key) => { if(newSpell[key]) acc[key] = newSpell[key]; return acc; }, {}));

                    if (cleanExisting !== cleanNew) {
                         const userChoice = await openConflictModal(existingSpell, newSpell);
                        if (userChoice === 'replace') {
                            spellsToUpload.set(newSpell['Spell Name'], newSpell);
                        }
                    }
                } else {
                    spellsToUpload.set(newSpell['Spell Name'], newSpell);
                }
            }
            
            if (spellsToUpload.size > 0) {
                 try {
                    const batch = writeBatch(db);
                    spellsToUpload.forEach((spell, name) => {
                        const docId = name.replace(/\//g, "-");
                        const spellRef = doc(db, "spells", docId);
                        batch.set(spellRef, spell);
                    });
                    await batch.commit();
                    alert(`Import complete! ${spellsToUpload.size} spells were added or updated.`);
                 } catch (error) {
                    console.error("Error writing spells to Firestore:", error);
                    alert("There was an error saving the imported spells to the database. Please check your Firestore security rules.");
                 }
            } else {
                 alert("Import complete. No new spells or changes were found.");
            }
        }
        
        // --- MODALS ---
        function createModal(id, contentHtml) {
            const modalEl = document.createElement('div');
            modalEl.id = id;
            modalEl.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 modal-overlay z-50';
            modalEl.innerHTML = contentHtml;
            document.getElementById('modal-container').appendChild(modalEl);
            return modalEl;
        }

        function closeModal(modal) {
             if (modal) {
                modal.remove();
             }
        }
        
        function openGoogleSheetImportModal() {
            if (document.getElementById('google-sheet-import-modal')) return;
            const modalContent = `<div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md">
                <form id="google-sheet-import-form" class="p-6 space-y-4">
                     <div class="flex justify-between items-center border-b pb-3 dark:border-gray-600">
                        <h2 class="text-2xl font-bold">Import from Google Sheet</h2>
                        <button type="button" onclick="closeModal(document.getElementById('google-sheet-import-modal'))" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 text-3xl">&times;</button>
                     </div>
                     <div>
                        <label class="block text-sm font-medium">Google Apps Script URL*</label>
                        <input type="url" name="url" required class="mt-1 block w-full p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600" placeholder="https://script.google.com/macros/s/.../exec">
                        <p class="text-xs text-gray-500 mt-1">This requires setting up a Google Apps Script. See setup instructions for details.</p>
                     </div>
                     <div class="flex justify-end pt-4">
                        <button type="button" onclick="closeModal(document.getElementById('google-sheet-import-modal'))" class="mr-3 px-4 py-2 bg-gray-200 dark:bg-gray-600 rounded-md">Cancel</button>
                        <button type="submit" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Import</button>
                     </div>
                </form>
             </div>`;
            const modal = createModal('google-sheet-import-modal', modalContent);
            modal.querySelector('form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const url = e.target.elements.url.value;
                if(url) {
                    try {
                        const response = await fetch(url);
                        if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);
                        const data = await response.json();
                        if (data && data.spells) {
                            await processImportedSpells(data.spells);
                            closeModal(modal);
                        } else {
                            throw new Error("JSON response did not contain a 'spells' array.");
                        }
                    } catch (error) {
                        console.error("Error fetching from Google Sheet URL:", error);
                        alert(`Failed to import from URL. Please check the link and ensure the script is deployed correctly. Error: ${error.message}`);
                    }
                }
            });
        }
        
        async function openAddSpellModal() {
            if (document.getElementById('add-spell-modal')) return;
            const modalContent = `<div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-lg max-h-[90vh] overflow-y-auto custom-scrollbar">
                <form id="add-spell-form" class="p-6 space-y-4">
                    <div class="flex justify-between items-center border-b pb-3 dark:border-gray-600"><h2 class="text-2xl font-bold">Add a New Spell</h2><button type="button" onclick="closeModal(document.getElementById('add-spell-modal'))" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 text-3xl">&times;</button></div>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <div><label class="block text-sm font-medium">Spell Name*</label><input type="text" name="Spell Name" required class="mt-1 block w-full p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600"></div>
                         <div><label class="block text-sm font-medium">Level*</label><input type="text" name="Level" required class="mt-1 block w-full p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600"></div>
                        <div><label class="block text-sm font-medium">School</label><input type="text" name="School" class="mt-1 block w-full p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600"></div>
                        <div><label class="block text-sm font-medium">Casting Time</label><input type="text" name="Casting Time" class="mt-1 block w-full p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600"></div>
                        <div><label class="block text-sm font-medium">Range</label><input type="text" name="Range" class="mt-1 block w-full p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600"></div>
                         <div><label class="block text-sm font-medium">Components</label><input type="text" name="Components" class="mt-1 block w-full p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600"></div>
                    </div>
                     <div><label class="block text-sm font-medium">Duration</label><input type="text" name="Duration" class="mt-1 block w-full p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600"></div>
                    <div><label class="block text-sm font-medium">Description*</label><textarea name="Description" rows="4" required class="mt-1 block w-full p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600"></textarea></div>
                     <div><label class="block text-sm font-medium">At Higher Levels</label><textarea name="Higher Level" rows="2" class="mt-1 block w-full p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600"></textarea></div>
                    <div class="flex justify-end pt-4"><button type="button" onclick="closeModal(document.getElementById('add-spell-modal'))" class="mr-3 px-4 py-2 bg-gray-200 dark:bg-gray-600 rounded-md">Cancel</button><button type="submit" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Save Spell</button></div>
                </form>
            </div>`;
            const modal = createModal('add-spell-modal', modalContent);
            modal.querySelector('form').addEventListener('submit', async (event) => {
                event.preventDefault();
                const formData = new FormData(event.target);
                const newSpell = Object.fromEntries(formData.entries());
                if (!newSpell['Spell Name'] || !newSpell['Level'] || !newSpell['Description']) {
                    alert('Please fill out all required fields.'); return;
                }
                const spellName = newSpell['Spell Name'];
                if(allSpells.some(s => s['Spell Name'].toLowerCase() === spellName.toLowerCase())) {
                    alert('A spell with this name already exists.'); return;
                }
                const docId = spellName.replace(/\//g, "-");
                try {
                    await setDoc(doc(db, "spells", docId), newSpell);
                    closeModal(modal);
                } catch(error) {
                    console.error("Error saving new spell:", error);
                    alert("Could not save the new spell. Please check your connection and Firestore security rules.");
                }
            });
        }

        async function openAddPersonaModal() {
             if (document.getElementById('add-persona-modal')) return;
             const modalContent = `<div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md">
                <form id="add-persona-form" class="p-6 space-y-4">
                     <div class="flex justify-between items-center border-b pb-3 dark:border-gray-600"><h2 class="text-2xl font-bold">Create New Player</h2><button type="button" onclick="closeModal(document.getElementById('add-persona-modal'))" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 text-3xl">&times;</button></div>
                     <div><label class="block text-sm font-medium">Player Name*</label><input type="text" name="name" required class="mt-1 block w-full p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600"></div>
                     <div><label class="block text-sm font-medium">Owner PIN (4 digits, optional)</label><input type="text" name="ownerPin" pattern="\\d{4}" maxlength="4" placeholder="For editing/deleting" class="mt-1 block w-full p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600"></div>
                     <div><label class="block text-sm font-medium">Guest PIN (4 digits, optional)</label><input type="text" name="guestPin" pattern="\\d{4}" maxlength="4" placeholder="For view-only access" class="mt-1 block w-full p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600"></div>
                     <div class="flex justify-end pt-4"><button type="button" onclick="closeModal(document.getElementById('add-persona-modal'))" class="mr-3 px-4 py-2 bg-gray-200 dark:bg-gray-600 rounded-md">Cancel</button><button type="submit" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Create Player</button></div>
                </form>
             </div>`;
             const modal = createModal('add-persona-modal', modalContent);
             modal.querySelector('form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const formData = new FormData(e.target);
                const name = formData.get('name').trim();
                const ownerPin = formData.get('ownerPin').trim();
                const guestPin = formData.get('guestPin').trim();
                const ownerPinHash = await hashPin(ownerPin);
                const guestPinHash = await hashPin(guestPin);

                if (name && !personas[name]) {
                    personas[name] = { spells: [], ownerPinHash, guestPinHash };
                    await savePersonas();
                    document.getElementById('persona-select').value = name;
                    handlePersonaChange();
                    closeModal(modal);
                } else if(personas[name]) {
                    alert('A player with this name already exists.');
                }
             });
        }
        
        async function openPinModal(title, message, callback, isLogin = false) {
            const modalId = 'pin-modal';
            if (document.getElementById(modalId)) return;
            const modalContent = `<div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-sm text-center">
                <div class="p-6 space-y-4">
                    <h2 class="text-2xl font-bold">${title}</h2>
                    <p class="text-gray-600 dark:text-gray-300">${message}</p>
                    <div class="flex justify-center gap-2" id="pin-inputs">
                        ${[...Array(4)].map(() => `<input type="password" maxlength="1" class="pin-input border rounded-md dark:bg-gray-700 dark:border-gray-600">`).join('')}
                    </div>
                     <div class="flex justify-center pt-4 gap-4">
                        <button id="pin-cancel-btn" class="flex-1 px-4 py-2 bg-gray-200 dark:bg-gray-600 rounded-md">Cancel</button>
                        <button id="pin-submit-btn" class="flex-1 px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Submit</button>
                     </div>
                </div>
            </div>`;
            const modal = createModal(modalId, modalContent);
            const inputs = modal.querySelectorAll('.pin-input');
            const submitBtn = modal.querySelector('#pin-submit-btn');
            
            inputs[0].focus();
            inputs.forEach((input, index) => {
                input.addEventListener('keydown', (e) => {
                    if (e.key >= 0 && e.key <= 9) {
                        inputs[index].value = '';
                        setTimeout(() => { if (index < 3) inputs[index + 1].focus() }, 10);
                    } else if (e.key === 'Backspace') {
                         setTimeout(() => { if (index > 0) inputs[index - 1].focus() }, 10);
                    }
                });
            });

            const handleSubmit = () => {
                const pin = Array.from(inputs).map(i => i.value).join('');
                if (pin.length === 4) {
                    callback(pin);
                    closeModal(modal);
                } else {
                    alert("Please enter a 4-digit PIN.");
                }
            };

            submitBtn.onclick = handleSubmit;
            modal.querySelector('#pin-cancel-btn').onclick = () => {
                if(isLogin) document.getElementById('persona-select').value = '';
                closeModal(modal);
            };
        }

        function openConflictModal(existingSpell, newSpell) {
            return new Promise((resolve) => {
                 const modalId = 'conflict-modal';
                 if (document.getElementById(modalId)) document.getElementById(modalId).remove();
                 const modalContent = `<div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
                    <div class="p-4 border-b dark:border-gray-700">
                        <h2 class="text-2xl font-bold">Spell Conflict Detected for "${newSpell['Spell Name']}"</h2>
                        <p>An existing spell has the same name but different data. Choose which version to keep.</p>
                    </div>
                    <div class="p-6 grid grid-cols-2 gap-6 overflow-y-auto">
                        <div><h3 class="font-bold text-lg mb-2">Existing Spell</h3><div id="existing-spell-details"></div></div>
                        <div><h3 class="font-bold text-lg mb-2">New Spell from CSV</h3><div id="new-spell-details"></div></div>
                    </div>
                    <div class="p-4 border-t dark:border-gray-700 flex justify-end gap-4">
                        <button id="conflict-keep-btn" class="px-4 py-2 bg-gray-200 dark:bg-gray-600 rounded-md">Keep Existing</button>
                        <button id="conflict-replace-btn" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Replace with New</button>
                    </div>
                 </div>`;
                const modal = createModal(modalId, modalContent);
                
                const renderDetails = (spell, containerId) => {
                    const container = modal.querySelector(`#${containerId}`);
                    container.innerHTML = Object.entries(spell).map(([key, value]) => `<div><strong class="text-sm">${key}:</strong> ${value || 'N/A'}</div>`).join('');
                };
                renderDetails(existingSpell, 'existing-spell-details');
                renderDetails(newSpell, 'new-spell-details');
                
                modal.querySelector('#conflict-keep-btn').onclick = () => { closeModal(modal); resolve('keep'); };
                modal.querySelector('#conflict-replace-btn').onclick = () => { closeModal(modal); resolve('replace'); };
            });
        }
        
        // --- GLOBAL ACCESS ---
        window.openGoogleSheetImportModal = openGoogleSheetImportModal;
        window.handleCsvFileSelect = handleCsvFileSelect;
        window.openAddSpellModal = openAddSpellModal;
        window.openAddPersonaModal = openAddPersonaModal;
        window.requestDeletePersona = requestDeletePersona;
        window.switchToViewMode = switchToViewMode;
        window.requestEditMode = requestEditMode;
        window.handleSearch = handleSearch;
        window.displaySpellCard = displaySpellCard;
        window.addSpellToPersona = addSpellToPersona;
        window.removeSpellFromPersona = removeSpellFromPersona;
        window.closeModal = closeModal;

        // --- SCRIPT START ---
        document.addEventListener('DOMContentLoaded', () => {
            initTheme();
            initializeFirebase();
        });

    </script>
</body>
</html>

